# 【Java8】异步编程 CompletableFuture

## 一 、认识异步编程

通常Java开发人员喜欢使用同步代码编写程序,因为这种请求(request)/响应(response)的方式比较简单，并且比较符合编程人员的思维习惯;这种做法很好，直到系统出现性能瓶颈；在同步编程方式时由于每个线程同时只能发起一个请求并同步等待返回，所以为了提高系统性能，此时我们就需要引入更多的线程来实现并行化处理；

我们但是同步以及多线程模式下的的缺点也是很明显的:

- 多线程下对共享资源进行访问时，不可避免会引入资源争用和并发问题；
- 另外操作系统层面对线程的个数是有限制的，不可能通过无限的增加线程数来提供系统性能；
- 使用同步阻塞的编程方式还会导致浪费资源，比如发起网络IO请求时候，调用线程就会处于同步阻塞等待响应结果的状态，而这时候调用线程明明可以去做其他事情，等网络IO响应结果返回后在对结果进行处理。
- Java中创建线程的2种方式 (直接继承 Thread 类，实现Runnable接口) 都有一个缺陷就是：在执行完任务之后无法获取执行结果。

***可见通过增加单机系统线程个数的并行编程方式并不是灵丹妙药；***通过编写异步、非阻塞的代码，则可以使用相同的底层资源将执行切换到另一个活动任务，然后在异步处理完成后在返回到当前线程进行继续处理，从而提高系统性能。

异步编程是可以让程序并行运行的一种手段，其可以让程序中的一个工作单元与主应用程序线程分开独立运行，并且等工作单元运行结束后通知主应用程序线程它的运行结果或者失败原因。使用它有许多好处，例如可以提高应用程序的性能和响应能力。

比如当调用线程使用异步方式发起网络IO请求后，调用线程就不会同步阻塞等待响应结果，而是在内存保存请求上下文后，会马上返回后做其他事情，等网络IO响应结果返回后在使用IO线程通知业务线程响应结果已经返回，然后业务线程在对结果进行处理。可知异步调用方式提高了线程的利用率，让系统有更多的线程资源来处理更多的请求。

比如在移动应用程序中，在用户操作移动设备屏幕发起请求后，如果是同步等待后台服务器返回结果，则当后台服务操作非常耗时时，就会造成用户看到移动设备屏幕冻结（一直处理请求处理中），在结果返回前，用户不能操作移动设备的其他功能，这对用户体验非常不好。而使用异步编程则当发起请求后，调用线程会马上返回，具体返回结果则会通过UI线程异步进行渲染，而在这期间用户可以使用移动设备的其他功能。

## 二、 异步编程场景概述

在日常开发中我们经常会遇到这样的情况，就是需要异步的处理一些事情，而不需要知道异步任务的结果；

比如在调用线程里面异步打日志，为了不让日志打印阻塞调用线程，会把日志设置为异步方式。如下图1-2-1日志异步化打印，使用一个内存队列把日志打印异步化，使用单一线程来消费队列里面日志事件执行具体的日志落盘操作（本质是一个多生产单消费模型），这种情况下调用线程把日志任务放入队列后就继续去干自己的事情了，而不再关心日志任务具体是什么时候入盘的；

![](https://pic2.zhimg.com/80/v2-aa7520d7b9e0b65949073cfc12df18ed_1440w.jpg)

在Java中每当我们需要执行异步任务的时候我们可以直接开启一个线程来实现，也可以把异步任务封装为任务对象投递到线程池里面来执行，在Spring框架中则提供了@Async注解把一个任务异步化来进行处理，这些内容会在后面章节具体讲解。

另外有时候我们还需要在主线程等待异步任务的执行结果，这时候Future就排上用场了；比如调用线程要等执行任务A执行完毕后在顺序执行任务B，并且把两者结果拼接起来作为前端展示使用，如果调用线程是同步调用两次查询（如下图1-2-2同步调用），则整个过程耗时时间为执行任务A的耗时加上执行任务B的耗时。