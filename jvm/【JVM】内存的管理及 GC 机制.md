## 【JVM】内存管理及 GC 机制

首先，第一个问题：JVM的内存区域是怎么高效划分的？这也是一个高频的面试题。很多同学可能通过死记硬背的方式来应对这个问题，这样不仅对知识没有融会贯通在面试中还很容易忘记答案。

为什么要问到 JVM 的内存区域划分呢？因为 Java 引以为豪的就是它的自动内存管理机制。相比于 C++的手动内存管理、复杂难以理解的指针等，Java 程序写起来就方便的多。

然而这种呼之即来挥之即去的内存申请和释放方式，自然也有它的代价。为了管理这些快速的内存申请释放操作，就必须引入一个池子来延迟这些内存区域的回收操作。

我们常说的内存回收，就是针对这个池子的操作。我们把上面说的这个池子，叫作***堆***，可以暂时把它看成一个整体。

### 一、 JVM 的内存区域

#### 1.1 内存布局

程序想要运行，就需要数据。有了数据，就需要在内存上存储。那你可以回想一下，我们的 C++ 程序是怎么运行的？是不是也是这样？

Java 程序的数据结构是非常丰富的。其中的内容，举一些例子：

- 静态成员变量
- 动态成员变量
- 区域变量
- 短小紧凑的对象声明
- 庞大复杂的内存申请 

这么多不同的数据结构，到底是在什么地方存储的，它们之间又是怎么进行交互的呢？是不是经常在面试的时候被问到这些问题？

我们先看一下 JVM 的内存布局。随着 Java 的发展，内存布局一直在调整之中。比如，Java 8 及之后的版本，彻底移除了***永久代(方法区)***，而使用 ***Metaspace(元数据区)*** 来进行替代。这也表示着 -XX:PermSize 和 -XX:MaxPermSize 等参数调优，已经没有了意义。但大体上，比较重要的内存区域是固定的。

![JVM8 内存](/Users/sherlock/Desktop/notes/allPics/Jvm/JVM8 内存.png)

JVM 内存区域划分如图所示，从图中我们可以看出：

-  JVM 堆中的数据是共享的，是占用内存最大的一块区域。
- 可以执行字节码的模块叫作执行引擎。
- 执行引擎在线程切换时怎么恢复？依靠的就是程序计数器。
- JVM 的内存划分与多线程是息息相关的。像我们程序中运行时用到的栈，以及本地方法栈，它们的维度都是线程。
- 本地内存包含元数据区和一些直接内存。



##### 1.1.1 虚拟机栈

栈是什么样的数据结构？你可以想象一下子弹上膛的这个过程，后进的子弹最先射出，最上面的子弹就相当于栈顶。

我们在上面提到，Java 虚拟机栈是基于线程的。哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。

栈中的数据结构，就是栈帧。在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。每个栈帧，都包含四个区域：

- 局部变量表
- 操作数栈 
- 动态连接
- 返回地址

我们的应用程序，就是在不断操作这些内存空间中完成的。

![jvm 栈](/Users/sherlock/Desktop/notes/allPics/Jvm/jvm 栈.png)

本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法。你甚至可以认为虚拟机栈和本地方法栈是同一个区域，这并不影响我们对 JVM 的了解。

这里有一个比较特殊的数据类型叫作 returnAddress。因为这种类型只存在于字节码层面，所以我们平常打交道的比较少。对于 JVM 来说，程序就是存储在方法区的字节码指令，而 returnAddress 类型的值就是指向特定指令内存地址的指针。

![stack](/Users/sherlock/Desktop/notes/allPics/Jvm/stack.png)

1. 这里有一个两层的栈。第一层是栈帧，对应着方法；第二层是方法的执行，对应着操作数。注意千万不要搞混了。

2. 你可以看到，所有的字节码指令，其实都会抽象成对栈的入栈出栈操作。执行引擎只需要傻瓜式的按顺序执行，就可以保证它的正确性。

##### 1.1.2 程序计数器

设想一下，如果程序在线程之间进行切换，凭什么能够知道这个线程已经执行到什么地方呢？

既然是线程，就代表它在获取 CPU 时间片上，是不可预知的，需要有一个地方，对线程正在运行的点位进行缓冲记录，以便在获取 CPU 时间片时能够快速恢复。

就好比你停下手中的工作，倒了杯茶，然后如何继续之前的工作？

程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。这里面存的，就是当前线程执行的进度。下面这张图，能够加深大家对这个过程的理解。

![pc寄存器](/Users/sherlock/Desktop/notes/allPics/Jvm/pc寄存器.png)

可以看到，程序计数器也是因为线程而产生的，与虚拟机栈配合完成计算操作。程序计数器还存储了当前正在运行的流程，包括正在执行的指令、跳转、分支、循环、异常处理等。

我们可以看一下程序计数器里面的具体内容。下面这张图，就是使用 javap 命令输出的字节码。大家可以看到在每个 opcode 前面，都有一个序号。就是图中红框中的偏移地址，你可以认为它们是程序计数器的内容。

![javap](/Users/sherlock/Desktop/notes/allPics/Jvm/javap.png)

##### 1.1.3 堆

堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。

堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。

随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。

由于对象的大小不一，在长时间运行后，堆空间会被许多细小的碎片占满，造成空间浪费。所以，仅仅销毁对象是不够的，还需要堆空间整理。这个过程非常的复杂，我们会在后面有专门的课时进行介绍。

那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 Java 类中存在的位置。

Java 的对象可以分为基本数据类型和普通对象。

对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。

对于基本数据类型（byte、short、int、long、float、double、char) 来说，有两种情况。

我们上面提到，每个线程拥有一个虚拟机栈。

1. 当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。
2. 其他情况，都是在堆上分配。

注意，像 int[] 数组这样的内容，是在堆上分配的。数组并不是基本数据类型。

![heap](/Users/sherlock/Desktop/notes/allPics/Jvm/heap.png)

这就是 JVM 的基本的内存分配策略。而堆是所有线程共享的，如果是多个线程访问，会涉及数据同步问题。这同样是个大话题，我们在这里先留下一个悬念。

##### 1.1.4 元空间

关于元空间，我们还是以一个非常高频的面试题开始：“为什么有 Metaspace 区域？它有什么问题？”

说到这里，你应该回想一下类与对象的区别。对象是一个活生生的个体，可以参与到程序的运行中；类更像是一个模版，定义了一系列属性和操作。那么你可以设想一下。我们前面生成的 A.class，是放在 JVM 的哪个区域的？

想要问答这个问题，就不得不提下 Java 的历史。在 Java 8 之前，这些类的信息是放在一个叫 Perm 区的内存里面的。更早版本，甚至 String.intern 相关的运行时常量池也放在这里。这个区域有大小限制，很容易造成 JVM 内存溢出，从而造成 JVM 崩溃。

Perm 区在 Java 8 中已经被彻底废除，取而代之的是 Metaspace。原来的 Perm 区是在堆上的，现在的元空间是在非堆上的，这是背景。关于它们的对比，可以看下这张图。

![ jdk8 前后方法区对比](/Users/sherlock/Desktop/notes/allPics/Jvm/ jdk8 前后方法区对比.png)

然后，元空间的好处也是它的坏处。使用非堆可以使用操作系统的内存，JVM 不会再出现方法区的内存溢出；但是，无限制的使用会造成操作系统的死亡。所以，一般也会使用参数 

`-XX:MaxMetaspaceSize` 来控制大小。

方法区，作为一个概念，依然存在。它的物理存储的容器，就是 Metaspace。我们将在后面会讲到，再次遇到它。现在，你只需要了解到，这个区域存储的内容，包括：类的信息、常量池、方法数据、方法代码就可以了。

1. 我们常说的字符串常量，存放在哪呢？

   由于常量池，在 Java 7 之后，放到了堆中，我们创建的字符串，将会在堆上分配。

2. 堆、非堆、本地内存，有什么关系？

   堆是软绵绵的，松散而有弹性；而非堆是冰冷生硬的，内存非常紧凑。



#### 1.2 对象的创建

在语言层面，创建对象（例如：clone，反序列化）通常是一个 new 关键字，而在虚拟机中，对象创建的过程是如何呢？

在虚拟机遇到 new 指令时：

1. ***类加载***

   确保常量池中存放的是已解释的类，且对象所属类型已经初始化过，如果没有，则先执行类加载

2. ***为新生对象分配内存***

   对象所需内存大小在类加载时可以确定，将确定大小的内存从Java堆中划分出来

   - 分配空闲内存方法：
     - 指针碰撞：假如堆是规整的，用过的内存和空闲的内存各一边，中间使用指针作为分界点，分配内存时则将指针移动对象大小的距离
     - 空闲列表：假如堆是不规整的，虚拟机需要维护哪些内存块是可用的列表，分配时候从列表中找出足够大的空闲内存划分，并更新列表记录
   - 对象创建在并发情况下保证线程安全：例如，正在给对象A分配内存，指针还没修改，对象B同时使用了原来的指针来分配内存
     - CAS配上失败重试
     - 本地线程分配缓冲TLAB（ThreadLocal Allocation Buffer）：将内存分配动作按线程划分到不同空间中进行，即每个线程在Java堆中预先分配一小块内存

3. ***将分配的内存空间初始化为零值***

   保证对象的实例在Java代码中可以不赋值就可直接使用，能访问到这些字段的数据类型对应的零值（例如，int类型参数默认为0）

4. ***设置对象头***

   设置对象的类的元数据信息、哈希码、GC分代年龄等

5. ***执行<init>方法初始化***

   将对象按照程序员的意愿初始化

 

#### 1.3 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局分为3个区域，如下图所示：

![对象](/Users/sherlock/Desktop/notes/allPics/Jvm/对象.png)

- **对象头（Header）**：

  - **MarkWord (8byte)**：存储对象自身的运行时数据，例如：哈希码HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。考虑空间效率，MarkWord设计为非固定的数据结构，它根据对象的不同状态复用自己的空间，如下图所示：

    ![markword](/Users/sherlock/Desktop/notes/allPics/Jvm/markword.png)

  - **class pointer (开启压缩 4byte)**：即对象指向它的类的元数据的指针，虚拟机通过这个指针来确定是哪个类的实例
  - 如果对象是Java数组，对象头中还需要一块记录数组长度的数据 (4 byte)

- **实例数据（Instance Data）**：对象真正存储的有效信息，也是程序代码中定义的各种类型字段的内容
- **对齐填充（Padding）**：起占位符的作用。因为HotSpot VM的要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。当对象实例数据部分没有对齐时，需要对齐填充来补充

> 具体详见 [Java对象在内存中的布局](/Users/sherlock/Desktop/notes/jvm/[JVM]对象在内存中的布局.md)

#### 1.4 内存溢出异常

除程序计数器外，JVM其他几个运行时区域都可能发生 ***OutOfMemoryError*** 异常。

##### 1.4.1 堆内存溢出，OutOfMemoryError:java heap space

  **原因**：Java堆用于存储对象实例，只要不断创建对象，并保证GC Roots到对象间有可达路径避免这些对象的GC，当对象数量达到堆的最大容量限制后就会产生OOM

  **解决方法**：

- 通过参数 -XX:HeapDumpOnOutOfMemoryError 可以让虚拟机在内存溢出异常时Dump当前内存堆转储快照
- 通过内存映像分析工具（如：Eclipse Memory Analyzer）对Dump出的堆转储快照分析，判断是内存泄露还是内存溢出
- 如果是内存泄露：通过工具查看泄露对象的类型信息和它们到 GC Roots 的引用链信息，分析GC收集器无法自动回收它们的原因，定位内存泄露的代码位置
- 如果是内存溢出：检查堆参数 -Xms和-Xmx，看是否可调大；代码上检查某些对象生命周期过长，持有时间过长的情况，尝试减少程序运行期间内存消耗

##### 1.4.2 栈内存溢出，StackOverflowError

  **原因**：

- StackOverFlowError异常：线程请求的栈深度大于虚拟机所允许的最大深度
- OutOfMemoryError异常：虚拟机扩展栈时无法申请足够的内存空间

  **解决方法**：

- 检查代码中是否有死递归；配置 -Xss 增大每个线程的栈内存容量，但会减少工作线程数，需要权衡

### 二、垃圾回收策略

#### 2.1 对象存活判断

堆中存放着几乎所有的对象实例，GC收集器在对堆进行回收前，首先要确定哪些对象是“存活”的，哪些是“死去”的

##### 2.1.1 **引用计数法**

给每个对象添加一个引用计数器，每当有地方引用它时，计数器 +1；引用失效时，计数器 -1。当计数器为0时对象就不再被引用。

但主流Java虚拟机没有采用这种算法，主要原因是：**它难以解决对象之间循环引用的问题**

##### 2.1.2  **可达性分析算法**

以一系列称为 ***GC Roots*** 的对象作为起始点，从这些节点向下搜索，搜索的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连（即从 GC Roots 到该对象不可达），则此对象是不可用的，会判断为可回收对象。

Java中，可作为 ***GC Roots*** 的对象包括：

- 栈（栈帧中的本地变量表）中引用的对象
- 方法区中类 static 静态属性引用的对象
- 方法区中 final 常量引用的对象
- 本地方法栈中 JNI 引用的对象 

#### 2.2 垃圾回收区域

垃圾回收主要区域是 ***堆内存***。在堆中，新生代常规应用进行一次GC一般可回收 70%~95% 的空间，永久代的 GC效率远低于此.

***方法区*** 进行垃圾回收的 “性价比” 一般比较低，主要回收两部分内容：废弃常量和无用的类

- 废弃常量回收：假如常量池的字符串，例如：“abc”，当前系统没有任何一个String对象引用这个字面量，则“abc”常量会被清理出常量池。常量池中的其他类、方法、字段的符号引用与此类似
- 无用的类回收：类需要满足下面3个条件才算是“无用的类”
  - 该类的堆中所有实例都被回收
  - 加载该类的 Class Loader 已被回收
  - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方反射访问该类的方法

***堆外内存*** 是把内存对象分配在Java虚拟机的堆以外的内存 (其实就是操作系统的内存)，包括JVM自身运行过程中分配的内存，JNI 里分配的内存、java.nio.DirectByteBuffer 分配的内存等，这些内存直接受操作系统管理。这样能一定程度的减少GC对应用程序的影响。但 JVM 不直接管理这些堆外内存，存在 OOM 的风险，可以在 JVM 启动参数加上 ***-XX:MaxDirectMemorySize=*** 对申请的堆外内存大小进行限制, 而对于元数据空间的使用可以通过在 JVM 启动参数加上 ***-XX:MaxMetaspaceSize=*** 进行限制.

DirectByteBuffer 对象表示堆外内存，DirectByteBuffer 对象中持有 Cleaner 对象，它唯一保存了堆外内存的数据、开始地址、大小和容量。在创建完后的下一次 Full GC 时， Cleaner对象会对堆外内存回收

#### 2.3 垃圾回收算法

##### ① 标记-清除算法(Mark-Sweep)

![Mark-Sweep](/Users/sherlock/Desktop/notes/allPics/Jvm/Mark-Sweep.png)

标记-清除算法分为“标记”阶段和“清除”阶段。标记阶段是把所有活动对象都做上标记。清除阶段是把那些没有标记的对象（非活动对象）回收

它主要有两个不足：

1. 效率问题：标记和清除两个过程的效率都不高
2. 空间问题：标记清除之后会有大量不连续的内存碎片。空间碎片过多可能导致后续需要分配大对象时，无法找到足够的连续内存而不得不提前触发另一次 GC



##### ② 复制算法(Copying)

![copying](/Users/sherlock/Desktop/notes/allPics/Jvm/copying.png)

复制算法是将可用内存划分为大小相等的两块，每次只使用一块，当一块内存用完了，就将存活的对象复制到另一块上，然后将已使用的内存空间一次清理掉。

这样分配内存时不用考虑内存碎片等复杂情况，但代价是将内存缩小为原来的一半。当对象存活率较高时，就要较多的复制操作，效率也会降低。

现在的商业虚拟机都**采用复制算法来回收新生代**。IBM专门的研究表明：**新生代中对象 98% 是“朝生夕死”的**，所有不需要 1:1 来划分空间，HotSpot虚拟机是将内存分为1块大的 Eden 和 2块小的 Survivor 空间，大小比例为 8:1:1。每次使用 Eden 和 其中一块 Survivor。当回收时，将 Eden 和 一块 Survivor 中的存活对象复制到另一块 Survivor 上，最后清理掉刚才的 Eden 和 Survivor。新生代每次可利用的整个新生态内存的 90%，10% 会被浪费掉。但当每次回收多余 10% 对象存活时，即剩下一个 Survivor 空间不够时，需要老年代**内存担保**，这些对象将直接进入老年代中。 



##### ③ 标记-压缩算法(Mark-Compact)

![Mark-Compact](/Users/sherlock/Desktop/notes/allPics/Jvm/Mark-Compact.png)

***复制算法的高效性是建立在存活对象少, 垃圾对象多的前提下的***. 这种情况在新生代经常发生, 但是在老年代, 更常见的情况是大部分对象都是存活对象, 如果依然使用复制算法, 由于存活对象较多, 复制的成本的会很高, 因此基于老年代的垃圾回收特性, 需要使用其他算法.

***标记-压缩算法是一种老年代的回收算法***, 它在“标记”阶段和 标记-清除算法 一样，但后续是让所有存活对象压缩到内存的一端，然后清理掉端边界外的内存, 这种算法既避免了碎片的产生, 又不需要两块相同的的内存空间, 性价比高.

*<u>**标记-压缩算法的最终效果等同于标记-清除算法执行完成后在进行一次内存碎片的整理, 因此, 可以把它称为标记清除压缩算法.**</u>*



##### ④ 分代算法(Generation Collecting)

![Generation-Collection](/Users/sherlock/Desktop/notes/allPics/Jvm/Generation-Collection.png)

分代算法的思想是: 根据对象存活周期的不同将内存划分为几块看，一般把堆分为***“年轻代(DefNewGeneration)”***和***“老年代(TenuredGeneration)”***，根据各个年代的特点采用适当的收集算法。

**新生态中，每次 GC 只有少量的对象存活，就选用复制算法**，只需要付出少量存活对象的复制成本就可以完成收集

**老年代中，对象存活率高、没有额外的担保空间，就必须使用“标记-清除”或“标记-整理”算法**

为了支持新生代高频率的垃圾回收, 虚拟机可能使用一种叫做 "卡表(Card Table)" 的数据结构. 卡表为一个比特位集合, 每一个比特位可以用来表示老年代的某一区域的所有对象是否持有新生代对象的引用. 这样在新生代 GC 的时候, 可以不用花费大量时间扫描所有老年代的对象来确定每一个对象的引用关系, 可以先扫描卡表, 只有当卡表的标记位为 1 时, 才需要扫描给定区域的老年代对象, 而卡表位为 0 的老年代对象, 一定不含有新生代对象的引用. 

例如下图中, 卡表中每一位表示老年代 4KB 的空间, 卡表记录为 0 的老年代区域没有任何对象指向新生代, 只有卡表位为 1 的区域蔡有对象包含新生代引用, 因此, 在新生代 GC 时只需要扫描卡表位为 1 的老年代空间, 这种使用方式可以大大加快新生代的回收速度.

![卡表](/Users/sherlock/Desktop/notes/allPics/Jvm/卡表.png)



##### ⑤分区算法(Region)

![Region](/Users/sherlock/Desktop/notes/allPics/Jvm/Region.png)

分代算法按照对象生命周期的长短划分为两部分, 而分区算法则将整个堆空间划分成连续的不同小区间, 每一个小区间都是独立使用, 独立回收. 这种算法的好处是可以控制一次回收小区间的数量.

一般来说, 在相同条件下, 堆空间越大, 一次 GC 所花费的时间也就越长, 从而产生的停顿也越长. 为了更好的控制 GC 产生的停顿时长, 将一块大的内存区域分隔成多个小块, 根据目标停顿时间, 每次合理的回收若干个小区间, 而不是一次回收整个堆空间, 从而减少一次 GC 所产生的停顿

### 三、垃圾回收器比较

#### 3.1 垃圾回收性能指标

- **吞吐量**：运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）。吞吐量越高，CPU利用越高效，则算法越好
- **最大暂停时间**：因 GC 而暂停应用程序线程的最长时间。暂停时间越短，则算法越好

**高吞吐量和低暂停时间不可兼得**。为了获得最大吞吐量，JVM 必须尽可能少地运行 GC，只有在迫不得已的情况下才运行GC，比如：新生代或者老年代已经满了。但是推迟运行 GC 的结果是，每次运行 GC 时需要做的事情会很多，比如有更多的对象积累在堆上等待回收，因此每次的 GC 时间则会变高，由此引起的平均和最大暂停时间也会很高

#### 3.2 垃圾回收器

垃圾收集器是内存回收算法的具体实现。本文主要介绍 HotSpot 虚拟机中的垃圾回收器，如图所示：

![垃圾回收器](/Users/sherlock/Desktop/notes/allPics/Jvm/垃圾回收器.png)

如果两个收集器之间存在连线，说明他们可搭配使用。各垃圾回收器的功能比较如下表：

| 垃圾回收器        | 工作区域      | 回收算法         | 工作线程 | 和用户线程并行 | 描述                                                         |
| ----------------- | ------------- | ---------------- | -------- | -------------- | ------------------------------------------------------------ |
| Serial            | 新生代        | 复制             | 单线程   | 否             | client模式下默认的新生代的垃圾收集器, 简单高效, 不建议使用   |
| ParNew            | 新生代        | 复制             | 多线程   | 否             | Serial的多线程版本, server模式下首选, 并唯一和CMS搭配的新生代垃圾收集器 |
| Parallel Scavenge | 新生代        | 复制             | 多线程   | 否             | 目标是达到可控制的吞吐量                                     |
| Serial Old        | 老年代        | 标记-整理        | 单线程   | 否             | Serial 老年代版本, 给 client模式下的虚拟机使用               |
| Parallel Old      | 老年代        | 标记-整理        | 多线程   | 否             | Parallel Scavenge的老年代版本, 吞吐量优先                    |
| CMS               | 老年代        | 标记-清除        | 多线程   | 是             | 追求最短停顿回收时间                                         |
| G1                | 新生代+老年代 | 复制 + 标记-整理 | 多线程   | 是             | JDK9 默认的垃圾回收器                                        |

该选用哪一种垃圾回收器？

1. 客户端程序: 一般使用 -XX:+UseSerialGC (Serial + Serial Old). 特别注意, 当一台机器上起多个 JVM, 每个 JVM 也可以采用这种 GC 组合

2. 吞吐率优先的服务端程序（计算密集型）: -XX:+UseParallelGC 或者 -XX:+UseParallelOldGC

3. 响应时间优先的服务端程序: -XX:+UseConcMarkSweepGC

4. 响应时间优先同时也要兼顾吞吐率的服务端程序：-XX:+UseG1GC

### 四、CMS垃圾回收器

CMS（Concurrent Mark Sweep）垃圾收集器是以最短回收停顿时间为目标的垃圾收集器。一般B/S或互联网站的服务端比较重视响应速度，希望系统的停顿时间最短，从而带给用户更好的体验，CMS就比较符合这类应用的需求。

