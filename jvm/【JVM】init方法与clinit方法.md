## 【JVM】<init>方法与<clinit>方法

### init

java在编译之后会在字节码文件中生成<init>方法，称之为实例构造器，该实例构造器会将语句块、变量初始化、调用父类的构造器等操作收敛到方法中，收敛顺序为:	

> 1. 父类变量初始化块 
>
> 2. 父类语句块  
>
> 3. 父类构造函数 
>
> 4. 子类变量初始化块  
>
> 5. 子类语句块  
>
> 6. 子类构造函数

```
所谓收敛到方法中的意思是：将这些操作放入到中去执行。
```

### clinit

java在编译之后会在字节码文件中生成<clinit>方法，称之为类构造器，类构造器同实例构造器一样，也会将静态语句块、静态变量初始化，收敛到方法中，收敛顺序为 

> 1. 父类静态变量初始化 
> 2. 父类静态语句块 
> 3. 子类静态变量初始化 
> 4. 子类静态语句块。  
>
> 若父类为接口，则不会调用父类的clinit方法。一个类可以没有clinit方法. 

<clinit>方法是在类加载过程中执行的，而<init>是在对象实例化执行的，所以<clinit>一定比<init>先执行。所以整个顺序为： 

> 1. 父类静态变量初始化 
>
> 2. 父类静态语句块 
>
> 3. 子类静态变量初始化 
>
> 4. 子类静态语句块 
>
> 5. 父类变量初始化块 
>
> 6. 父类语句块 
>
> 7. 父类构造函数 
>
> 8. 子类变量初始化块  
>
> 9. 子类语句块  
>
> 10. 子类构造函数
>

***<u>这里有个很大的坑:</u>***

如果在编译期间可以把结果放入常量池的静态字段的引用, 不会引起类的初始化

```java
public class Demo{
  private static double d1 = 0.8;
	private static final double d2 = 0.9;
	private static final double d3 = Math.random();
}
```

上面三个变量只有d2的使用不会引起类的初始化, d1和d3的使用都引起类的初始化.

要知道类变量(static变量)在准备阶段初始化, 但不会赋值, 当使用了`double b4 = Demo.d1`或`Demo.d1 = 0.1`这种调用或赋值的方式在类的初始化过程中才会对类变量赋值!