# 【Scala】尾递归

## 概念

如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。

尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。

## 实例

为了理解尾递归是如何工作的，让我们再次以递归的形式计算阶乘。首先，这可以很容易让我们理解为什么之前所定义的递归不是尾递归。回忆之前对计算`n!`的定义：在每个活跃期计算n倍的(n－1)!的值，让`n=n－1`并持续这个过程直到`n=1`为止。这种定义不是尾递归的，因为每个活跃期的返回值都依赖于用n乘以下一个活跃期的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。现在让我们考虑以尾递归的形式来定义计算`n!`的过程。

这种定义还需要接受第二个参数a，除此之外并没有太大区别。a（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令`a=n*a`并且`n=n－1`。继续递归调用，直到`n=1`，这满足结束条件，此时直接返回a即可。

代码实例3-2给出了一个C函数facttail，它接受一个整数n并以尾递归的形式计算n的阶乘。这个函数还接受一个参数a，a的初始值为1。facttail使用a来维护递归层次的深度，除此之外它和fact很相似。读者可以注意一下函数的具体实现和尾递归定义的相似之处。

示例：以尾递归的形式计算阶乘的一个函数实现

```c
/*facttail.c*/
#include"facttail.h"
/*facttail*/

int facttail(int n, int a){
	/*Compute a factorialina tail - recursive manner.*/
	if (n < 0) return 0;              
	else if (n == 0) return 1;    
	else if (n == 1) return a;         
  else return facttail(n - 1, n * a);
}
```

示例中的函数是尾递归的，因为对`facttail`的单次递归调用是函数返回前最后执行的一条语句。在facttail中碰巧最后一条语句也是对facttail的调用，但这并不是必需的。换句话说，在递归调用之后还可以有其他的语句执行，只是它们只能在递归调用没有执行时才可以执行 。

尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如`f(n, sum) = f(n-1) +  value(n) + sum`; 会保存n个函数调用堆栈，而使用尾递归`f(n, sum) = f(n-1, sum+value(n));`  这样则只保留后一个函数堆栈即可，之前的可优化删去。

也许在C语言中有很多的特例，但编程语言不只有 [C语言](https://baike.baidu.com/item/C语言)，在函数式语言Erlang中（亦是栈语言），如果想要保持语言的高并发特性，就必须用尾递归来替代传统的递归。

## 尾递归与传统递归比较

以下是具体实例: 

线性递归: 

```c
long Rescuvie(long n) {        
	return (n == 1) ? 1 : n * Rescuvie(n - 1);      
}       
```

尾递归: 

```c
long TailRescuvie(long n, long a) {
  return (n == 1) ? a : TailRescuvie(n - 1, a * n);
}   

long TailRescuvie(long n) {
  //封装用的
	return (n == 0) ? 1 : TailRescuvie(n, 1);        
}        
```

当n = 5时 

 对于传统线性递归, 他的递归过程如下:                           

```
Rescuvie(5)
 
{5 * Rescuvie(4)}
 
{5 * {4 * Rescuvie(3)}}
 
{5 * {4 * {3 * Rescuvie(2)}}}
 
{5 * {4 * {3 * {2 * Rescuvie(1)}}}}
 
{5 * {4 * {3 * {2 * 1}}}}
 
{5 * {4 * {3 * 2}}}
 
{5 * {4 * 6}}
 
{5 * 24}
 
120
```

对于尾递归, 他的递归过程如下:

```
TailRescuvie(5)     // 所以在运算上和内存占用上节省了很多,直接传回结果
 
TailRescuvie(5, 1)                         return 120
                                                 ↑
TailRescuvie(4, 5)                         return 120
                                                 ↑
TailRescuvie(3, 20)                        return 120
                                                 ↑
TailRescuvie(2, 60)                        return 120
                                                 ↑
TailRescuvie(1, 120)                       return 120
                                                 ↑
120        //当运行到最后时,return a => return 120 ,将120返回上一级
```

说明:

尾递归的效果就是去除了将下层的结果再次返回给上层，需要上层继续计算才得出结果的弊端，如果仔细观看例子就可以看出，其实每个递归的结果是存储在第二个参数a中的，到最后一次计算的时候，会只返回一个a的值，但是因为是递归的原理虽然仍然要返回给上层，依次到顶部才给出结果，但是不需要再做计算了，这点的好处就是每次分配的内存不会因为递归而扩大。在效率上，两者的确差不多。

## 尾递归的优势

与普通递归相比，由于尾递归的调用处于方法的最后，因此方法之前所积累下的各种状态对于递归调用结果已经没有任何意义，因此完全可以把本次方法中留在堆栈中的数据完全清除，把空间让给最后的递归调用。这样的优化便使得递归不会在调用堆栈上产生堆积，意味着即时是“无限”递归也不会让堆栈溢出。这便是尾递归的优势。

