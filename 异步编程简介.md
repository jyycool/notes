# 异步编程简介

本文介绍了一种用于并发编程的异步模型。对于某些应用程序，异步模型可能会产生比传统多线程更好的性能。本文档中提供的大部分材料都来自Dave Peticola对twisted d1(异步编程的python框架)的精彩介绍。

## 一、MultiThreads VS Async

说实话多线程和异步是非常容易让人混淆的，好像产生的效果差不多，甚至有人称多线程为异步，实际上这两种技术背后的实现原理是不同的。

1. 假设您有2个任务，不涉及任何IO（在多处理器机器上）。在这种情况下，线程优于Async。因为 Async 会像单线程程序一样按顺序的执行你的任务。但是线程可以同时执行这两个任务。
2. 假设您有2个任务，涉及IO（在多处理器机器上）。在这种情况下，Async和Threads执行的操作大致相同（性能可能因核心数量，调度，任务过程密集程度等而异）。但是，Async 占用的资源更少，开销更低，并且在多线程程序上编程也更简单。

Async 如何运作？线程1执行任务1，因为它正在等待IO，它将被移动到IO等待队列。类似地，线程2执行任务2，因为它也涉及IO，它被移动到IO等待队列。一旦它们的IO请求得到解决，它就会被移动到就绪队列，因此调度程序可以安排线程执行。

异步执行任务1而不等待它的IO完成它, 继续执行任务2也不用等待IO的完成。。

异步最适合涉及Web服务调用，数据库查询调用等的任务，用于进程密集型任务的线程。

## 二、理论模型

首先我们将回顾两个熟悉的模型，以便与异步模型进行对比。作为说明，我们设想一个程序由三个概念上不同的任务组成，必须执行这三个任务才能完成程序。注意，我在使用task时，指的是非技术意义上的需要完成的事情。

我们要看的第一个模型是单线程同步模型，如下图1所示:

![](https://upload-images.jianshu.io/upload_images/2240629-97665d70ec07fb8c.png?imageMogr2/auto-orient/strip|imageView2/2)

这是最简单的编程风格。每个任务按顺序执行，一个任务完全结束后，另一个任务开始。而且，如果任务总是按照一定的顺序执行，那么后面的任务的执行就可以假定前面的所有任务都已经没有错误地完成了，它们的所有输出都可以使用——这在逻辑上是一种明确的简化。

我们可以对比图2中所示的单线程同步模型和多线程同步模型。

![](https://upload-images.jianshu.io/upload_images/2240629-a9196234fa70565f.png?imageMogr2/auto-orient/strip|imageView2/2)

在多线程模型中，每一个任务由一个独立的线程控制。这些线程由操作系统管理，在一个多处理器或多核的环境中，真正的并发执行，也可能在一个单处理器中交替的执行。关键是，在线程模型中，程序执行的细节由操作系统操作，程序员可能简单的认为指令流是同时执行的。尽管例图很简单，但实际上多线程编程会变得很复杂，因为线程之间在执行的过程中需要相互同步。线程通信和同步是一个高级的编程话题，掌握它可能有些困难。

一些程序使用多个进程实现并行性,而不是多个线程。虽然编程细节不同,在概念上是相同的模型，如图2所示

现在我们可以介绍异步模型了，如图3描述的那样：

![](https://upload-images.jianshu.io/upload_images/2240629-39a3649588431c96.png?imageMogr2/auto-orient/strip|imageView2/2)

在异步模型中，各个任务是相互交错的，由一个单线程控制。这要比多线程模型简单，因为程序员知道，当一个任务执行时，另一个任务不会被被执行。虽然在一个单核处理器的系统中，一个多线程的程序也是一种交错的模式，但程序员在思考时应该像图2那样，而不是图3，避免程序移植到多处理器的系统中发生错误。但在单线程异步模型中，无论是在单处理器还是多处理器中，都是交错的执行的。

异步编程模型和多线程模型还有另外一个不同点。在多线程系统中，推迟一个任务的执行而去执行另一个任务大大的超出了程序员的控制。尽管，这个在操作系统的控制下，但程序员只能猜测一个任务被推迟，另一个任务来替代，可能在任何可能的时候发生。相比较，在异步模型中，一个任务会继续执行除非显示的放弃控制权给另一个任务。

> 读到这里, 我有些困惑, 这篇理论中一直强调, 多线程和异步的区别, 异步是使用单线程来执行多 task, 它不会发生像多线程中 CPU 时间片轮询调度的情况
>
> 但是, 异步底层的实现不还是要依靠多线程来实现么? 

## 三、理论方向

我们已经看到异步模型在某些方面比线程模型更简单，因为只有一个指令流，任务显式地放弃控制，而不是任意挂起。但是异步模型显然引入了它自己的复杂性。程序员必须将每个任务组织为一个较小的步骤序列，这些步骤间歇地执行。如果一个任务使用另一个任务的输出，依赖的任务必须被写入，以接受一系列的比特和碎片的输入，而不是全部。

由于没有实际的并行性，从我们的图中可以看出，异步程序的执行时间和同步程序的执行时间一样长。但是存在一个条件，在这个条件下异步系统可以比同步系统执行得更好，有时甚至比同步系统更出色。

![](https://upload-images.jianshu.io/upload_images/2240629-58fb62e0dc35e475.png?imageMogr2/auto-orient/strip|imageView2/2/w/509)

在图3中，灰色的部分代表一个任务被阻塞不能进行任何的步骤。为什么一个任务会被阻塞？一个频率较高的原因是它在等待I/O，从一个外部的设备传输数据。一个典型的CPU处理数据的速率要比磁盘和网络链接快好几个数量级并能一直维持这个能力。因此，一个同步的程序如果执行大量的I/O操作将会花费很多的时间被中断当磁盘或网络被挂起

注意图4中的阻塞的程序模型，看起来特别的像图3中的异步的程序模型。这并不是一个巧合。***异步模型背后的一个基本的思想是，一个异步程序，和一个正常阻塞的同步程序相比，除了可以去执行其他的任务外还可以继续的执行其它的步骤***。所以一个异步的程序只会在没有任何任务执行步骤的时候才会被阻塞(一个异步的程序通常被称做一个非阻塞程序)。从一个任务切换到另一个任务，对应着一个任务刚好执行完或者是在某一点上被阻塞。当存在大量的阻塞任务时，一个异步的程序会比一个同步的程序表现得更好在花费的等待时间方面，当把一个大致相等的时间投入到实际工作中的单个任务上。

***和一个同步的程序相比，一个异步的程序在以下的情况中表现得更好：***

1. 存在大量的任务，大多数时间至少有一个任务在执行
2. 任务执行大量的I/O操作,导致一个同步的程序浪费大量的时间在阻塞当其他的任务可以执行时
3. 任务之间是相互独立的，各个任务很少需要内部的交流（例如一个任务等待另一个任务）

这些条件几乎完美地描述了一个典型的繁忙的网络服务器（如web服务器）在 C/S 环境中。每一个任务都代表一个客户端请求一接收请求并发送回应的I/O形式。实现一个网络服务器，异步编程模型是主要获选者，这就是为什么Twisted和Node.js，以及其他异步服务器库，近几年来越来越火。

***你可能会问，为什么不使用更多的线程？如果一个线程阻塞在I/O操作，另一个线程是不是可以继续执行操作？然而，随着线程数的不断增加，你的服务器可能会开始出现性能问题。对于每一个新的线程，线程状态的创建和维护有一些内存开销。从异步模型中得到的另一个优势是可以避免上下文的切换。操作系统每一次切换线程时都要保存一些相关的寄存器，内存映射，栈指针，FPU上下文等信息，因此其他的线程在恢复的时候可以继续的执行。这方面的开销是相当大的。***

## 四、事件驱动编程

我们已经看到，异步编程使我们能够花更少的时间等待，而只利用一个单一的线程。但我们如何能从中获益呢？考虑一个程序，等待从标准输入读取数据。

```c
void monitorStdin(void) {
  char input[500];
  while(1) {
    memset(input, '0', 500);
    scanf("%s", &input);
    printf("you typed $s\n", input)
  }
}
```

scanf函数将会被阻塞直到stdin文件描述符有数据到达。这就意味着线程不能执行任何其他的操作直到scanf函数返回。

大多数异步程序库遇到以上的程序会这样做：

1. 虽然阻塞在了scanf函数,继续执行后面的代码
2. 提供一段代码，当scanf()实际发现stdin上可用的数据时运行。在同步情况下，当scanf()返回时，该代码回调块将执行

如果你之前用过ajax，这个模式将会听起来很熟悉。这个模式被很多的GUI框架利用--“当这个按钮被点击的时候执行这个函数，但是不要一直等待着那个按钮被点击，这样会阻止我们做其他的事情”。如果你使用过Twisted 或者 Nodejs.你也会再次看到这种模式--提供一个回到函数去执行当某个事件在未来发生时。

libevent是一个异步事件通知库。虽然我们不会再这里使用libevent,但它是很多的异步程序框架的基础。libevent API提供了一种机制来执行一个回调函数,当一个特定事件发生在一个文件描述符上或超时。目前，libevent 支持 /dev/poll, kqueue, select, poll, and epoll，他们都有着不同的I/O通知的机制。libevent 提供了更高水平的抽象围绕着这些机制，根据具体的操作系统选择最好的一种。本篇文章将直接介绍select(),epoll(),但libevent可能在将来的异步编程中更加的有用。

## 五、select() 异步编程的拯救者

编写一个网络服务器，传统的方式是使主线程阻塞在accept()，等待客户端的连接。当一个连接到来时，服务器产生一个新的线程或进程，子进程/线程负责处理这个连接，主服务继续服务新的可能到来的连接。

> 网络 IO: bind/listen -> acccept -> recv -> 用户处理逻辑
>
> 传统方法是在 accept 接收到一个连接请求时, 就创建一个线程去处理这个请求, 但是当并发量巨大的时候, 会创建很多线程来处理请求, 这时 线程的上下文切换调度成本巨大. 会对服务器造成非常大的压力

使用select(),不需要为每一个客户端准备一个线程/进程，通常只需一个线程，复用所有的请求，尽可能多的服务更多的客户端。所有使用select()一个主要的优点是你的程序可能只需要一个进程/线程去处理所有的请求。所以你的程序不需要共享内存或者是原始的同步机制去实现进程或线程间的通信。

select()以阻塞的形式工作直到在指定的文件描述符（可以代表一个确切的文件，一个管道(pip),或者是socket）上发生了某些事件.某些事件代表了什么？数据到达，可以往一个文件中写入数据，超时等等---你告诉select，你想通过什么被唤醒。

大多数基于select()的实现的服务器都严格围绕着由这些组成的事件循环：

1. 用文件描述符填充 fd_set 这样的一个结构体当我们关心该文件描述符有数据到来时
2. 用文件描述符填充fd_set结构体当你想得到通知可以向这个文件中写入数据
3. 调用select()阻塞直到事件发生
4. 每一次select()返回时，检查任何一个文件描述符看是不是被唤醒的原因。如果是，为那个文件描述符提供服务无论你的服务器以何种特殊的方式。
5. 一直执行这个流程

## 六、异步编程的好处

对于任何应用程序而言，有两件事非常重要 -  可用性和性能。

1. ***可用性:*** 例如在内部对象中读取和填充数据，与SQL建立连接并将其保存在那里等。由于SQL在网络中的另一台机器上运行并在不同的进程下运行，因此可能会耗费时间并且可能需要更长的时间。

   因此，如果应用程序在单个线程上运行，那么屏幕将处于挂起状态，直到所有任务完成，这是非常糟糕的用户体验。这就是为什么现在许多应用程序和新框架完全依赖于异步模型。

2. ***性能:*** 应用程序的性能也非常重要。已经看到，在执行请求时，大约70-80％的时间在等待依赖任务时被浪费。因此，异步编程可以最大限度地利用它，一旦将任务传递给另一个进程（比如SQL），当前线程就会保存状态并可用于执行另一个任务。当SQL任务完成时, 任何空闲的线程可以进一步处理它。





