## 【Zookeeper】ZK简介

Zookeeper 在分布式系统中是一个非常重要的基础设施, 它解决了分布式系统中一些最基础的问题:

- 提供极低的延迟、超高可用的内存 KV 数据库服务
- 提供中心化的服务故障发现服务
- 提供分布式场景下的锁、Counter、Queue 等协调服务



Zookeeper 集群本身是一个服务高可用的集群, 通常由奇数个 (3, 5, 7, ......等) 节点组成, 集群的服务不会因为小于一半的节点宕机而受影响 (因为 ZK 选举算法需要有大于一般的节点数参与选举). Zookeeper 集群中多个节点都存储同一份数据, ***为了保证节点之间数据的一致性, zookeeper 使用 ZAB (Zookeeper Atomic Broadcast) 协议作为数据一致性的算法***. ZAB 是由 Paxos 算法改进而来.



### 一、Zookeeper 核心特性

Zookeeper 在使用 ZAB 协议保证多节点间数据一致性的基础上实现了很多其他工程特性, 以下这些特性对于实现分布式集群管理的诸多功能至关重要.

1. ***多节点类型***

   Zookeeper数据节点可以设置多种节点类型, 每种节点类型具有不同节点特性

   - ***持久节点 (Persistent)*** 

     节点创建后就会一直存在, 直到有删除操作主动清除这个节点.

   - ***临时节点 (Ephemeral)***

     临时节点的生命周期和客户端的 session 绑定. 也就是说, 如果客户端的 session 失效, 那么这个节点就会自动被清除掉.

     > 注意: 这里提到的 session 失效, 并非连接断开, 后面会提到这两者的区别; 

     另外, 在临时节点下, 不可以创建子节点

   - ***持久顺序节点 (Persistent_Sequential)***

     这类节点具有持久特性和顺序特性.

     持久特性就是一旦被创建就会永久存在, 直到被主动删除

     顺序特性表示父节点为它的第一级子节点维护一份时序, 记录每个子节点创建的先后顺序. 在实际实现中, Zookeeper会为顺序节点加上一个自增的数字后缀作为新的节点名.

   - ***临时顺序节点 (Epheneral_sequential)***

     这类节点具有临时特性和顺序特性.

     临时特性即 session 一旦结束, 节点就会被自动删除.

     顺序特性表示父节点为它的第一级子节点维护一份时序, 记录每个子节点创建的先后顺序.

2. ***Watcher 机制***

   Watch 机制是 Zookeeper 实现的一种事件一部反馈机制, 就像现实中读者订阅了某个主题, 这个主题一旦有更新都会第一时间反馈给该读者一样.

   - ***watcher 设置***

     Zookeeper 可以为读操作设置 watcher, 这些读操作包括 ***getChildren()***、***exists()***以及 ***getData()***. 

     其中通过 ***getChildren()*** 设置的 watcher 为子节点 watcher, 这类 watcher 关注的事件包括了子节点创建、删除等. 

     通过 exists() 和 getData() 设置的 watcher 为数据 watcher, 这类 watcher 关注的事件包含了节点数据发生更新、子节点发生创建删除操作等.

   - ***watcher 触发反馈***

     Zookeeper 客户端与服务器之间的连接是长连接. watcher 事件发生之后服务器端会发送一个信息给客户端, 客户端会调用预先准备的处理逻辑进行应对.

   - ***watcher 特性***

     watcher 事件是一次性的触发器, 当 watcher 关注的对象状态发生改变时, 将会触发此对象上所设置的 watcher 对应事件. 例如: 如果一个客户端通过 ***getData("/znode1", true)*** 操作给节点 /znode1 加上一个 watcher, 一旦 /znode1 的数据被改变或删除, 客户端就会获得一个关于 "znode1" 的事件. 但是如果 /znode1 再次改变, 那么将不会再有 watcher 事件反馈给客户端, 除非客户端重新设置一个 watcher.

3. ***Session 机制***

   Zookeeper 在启动时, 客户端会根据配置文件中 Zookeeper 服务器列表配置项, 选择其中任意一台服务器相连, 如果连接失败, 它会尝试连接另一台服务器, 直到与一台服务器成功建立连接或因为所有的 Zookeeper 服务都不可用而失败.

   一旦建立连接, Zookeeper就会为该客户创建一个新的 session. 每个 session 都会有一个超时时间设置, 这个设置由创建 session 的应用和服务器设置共同决定. 如果 Zookeeper 服务器在超市时间段内没有接收到任何请求, 则相应的 session 会过期, 一旦 session 过期, 任何与该 session 相关联的临时 znode 都会被清理. 临时 znode 一旦被清理, 注册在其上的 watcher 事件就会被触发.

   需要注意的是, Zookeeper 对于网络断开连接和 session 过期是两种处理机制.

   在客户端和服务端之间维持的是一个长连接, 在 session 超时时间内, 服务端会不断检测该客户端是否还处于正常连接, 服务端会将客户端每次操作视为一次有效的心跳检测来反复地进行 session 激活. 因此, 在正常情况下, 客户端 session 是一直有效的. 然而, 当客户端与服务端之间的连接断开后, 用户在客户端可能主要看到: ***CONNECTION_LOSS*** 和 ***SESSION_EXPIRED*** 两类异常

   - ***CONNECTION_LOSS*** : 网络一旦断开连接, 客户端就会收到 ***CONNECTION_LOSS*** 异常, 此时它会自动从 Zookeeper 服务器列表中重新选取地址, 并尝试重新连接, 直到最终成功连上服务器
   - ***SESSION_EXPIRED*** : 客户端与服务端断开连接后, 如果重连时间耗时太长, 超过了 session 超时时间, 服务器会进行 session 清理. ***注意: 此时客户端不知道 session 已经失效, 状态还是 DISCONNECTED, 如果客户端重新连上服务器, 此时状态会变更为 SESSION_EXPIRED***



### 二、Zookeeper 典型使用场景

Zookeeper 在实际集群管理中利用了上述工程特性可以实现非常多的分布式功能, 比如 HBase 使用 Zookeeper 实现了 Master 的高可用管理、RegionServer 的当即异常检测、分布式锁等一系列功能. 以分布式锁为例, 具体实现步骤如下:

1. 客户端调用 create() 方法创建名为 "locknode/lock-" 的节点, 需要注意的是, 节点的创建类型需要设置为 ***EPHEMERAL_SEQUENTIAL***.
2. 客户端调用 getChildren("locknode") 方法来获取已经创建的子节点
3. 客户端获取到所有子节点 path 之后, 如果发现自己在 步骤 1 中创建的子节点序号最小, 那么就认为客户端获取到了锁.
4. 如果在步骤 3 中发现自己并非所有子节点中最小的, 说明集群中其他进程获取到了这把锁. 此时客户端需要找到最小子节点, 然后对其调用 exist() 方法, 同时注册监听事件.
5. 一旦最小子节点对应的进程释放了分布式锁, 对应的临时节点就会被移除, 客户端因为注册了事件监听而收到相应的通知. 这个时候客户端需要再次调用 getChildren("locknode") 方法来获取所有已经创建的子节点, 之后进入步骤 3.

