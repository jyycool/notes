# 【Linux】kill

作为系统管理员，很重要的一个技能就是知道何时以及如何结束一个进程。有时进程挂起了，只需要动动手让进程重新运行或结束就行了。但有时，有的进程会耗尽CPU且不释放资源。在这两种情景下，你就需要能控制进程的命令。Linux 沿用了 Unix 进行进程间通信的方法。

在 Linux 中，进程之间通过**信号** 来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的程序都能接收和处理标准 Unix 进程信号。这些信号都列在了下表中。

**Linux进程信号**

| 信号 |  名称  |              描述              |
| :--: | :----: | :----------------------------: |
| `1`  | `HUP`  |              挂起              |
| `2`  | `INT`  |              中断              |
| `3`  | `QUIT` |            结束运行            |
| `9`  | `KILL` |           无条件终止           |
| `11` | `SEGV` |             段错误             |
| `15` | `TERM` |           尽可能终止           |
| `17` | `STOP` |    无条件停止运行，但不终止    |
| `18` | `TSTP` |  停止或暂停，但继续在后台运行  |
| `19` | `CONT` | 在`STOP` 或`TSTP` 之后恢复执行 |

在Linux上有两个命令可以向运行中的进程发出进程信号。

1. **kill** 命令

   `kill` 命令可通过进程ID（PID）给进程发信号。默认情况下，`kill` 命令会向命令行中列出的全部PID发送一个`TERM`信号。遗憾的是，你只能用进程的 PID 而不能用命令名，所以`kill` 命令有时并不好用。

   要发送进程信号，你必须是进程的属主或登录为root用户。

   ```sh
   $ kill 3940
   -bash: kill: (3940) - Operation not permitted
   ```

   `TERM` 信号告诉进程可能的话就停止运行。不过，如果有不服管教的进程，那它通常会忽略这个请求。如果要强制终止，`-s` 参数支持指定其他信号（用信号名或信号值）。

   你能从下例中看出，`kill` 命令不会有任何输出。

   ```sh
   # kill -s HUP 3940
   ```

   要检查`kill` 命令是否有效，可再运行`ps` 或`top` 命令，看看问题进程是否已停止。

2. **killall** 命令

   `killall` 命令非常强大，它支持通过进程名而不是PID来结束进程。`killall` 命令也支持通配符，这在系统因负载过大而变得很慢时很有用。

   ```sh
   # killall http*
   ```

   上例中的命令结束了所有以 http 开头的进程，比如 Apache Web 服务器的 httpd 服务。

   > **警告** 以root用户身份登录系统时，使用 `killall` 命令要特别小心，因为很容易就会误用通配符而结束了重要的系统进程。这可能会破坏文件系统。

