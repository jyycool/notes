# 【Linux】top

`ps` 命令虽然在收集运行在系统上的进程信息时非常有用，但也有不足之处: `它只能显示某个特定时间点的信息`。如果想观察那些频繁换进换出的内存的进程趋势，用 `ps` 命令就不方便了。

而 `top` 命令刚好适用这种情况。`top` 命令跟 `ps` 命令相似，能够显示进程信息，但它是实时显示的。下面是 `top` 命令运行时输出的截图。

```sh
Processes: 538 total, 2 running, 536 sleeping, 2324 threads                                           10:47:17
Load Avg: 2.36, 3.15, 3.16  CPU usage: 4.51% user, 4.75% sys, 90.73% idle
SharedLibs: 241M resident, 36M data, 21M linkedit.
MemRegions: 100404 total, 1149M resident, 54M private, 2161M shared.
PhysMem: 8170M used (1685M wired), 21M unused.
VM: 3110G vsize, 2305M framework vsize, 1301929(0) swapins, 1694502(0) swapouts.
Networks: packets: 990802/1182M in, 671394/568M out. Disks: 1594352/19G read, 316403/11G written.

PID   COMMAND      %CPU TIME     #TH   #WQ  #PORT MEM    PURG   CMPRS  PGRP PPID STATE    BOOSTS
709   iTerm2       9.5  00:41.83 9     6    305   98M-   2496K+ 48M-   709  1    sleeping *0[516+]
490   WindowServer 5.0  28:10.55 12    5    2446- 425M-  5244K+ 82M    490  1    sleeping *0[1]
2716  top          4.4  00:00.81 1/1   0    25    4364K  0B     0B     2716 2354 running  *0[1]
966   com.docker.h 2.8  06:43.89 11    0    34    2658M  0B     328M   949  958  sleeping *0[1]
0     kernel_task  2.6  14:30.26 176/4 0    0     658M-  0B     0B     0    0    running   0[0]
817  ~gamecontroll 1.1  01:53.35 4     3    80    1588K  0B     388K   817  1    sleeping *0[392813+]
394   com.apple.Ap 0.6  01:08.07 3     2    77    732K   0B     424K   394  1    sleeping  0[1]
2300  com.apple.We 0.5  04:09.75 6     3    112   152M-  8668K  24M-   2300 1    sleeping *0[220656]
137   bluetoothd   0.5  00:20.91 4     2    163+  2868K+ 0B     1068K  137  1    sleeping *0[1]
957   vpnkit-bridg 0.4  00:41.56 8     0    28    6632K  0B     1804K  949  949  sleeping *0[1]
681   useractivity 0.3  00:02.60 5     4    112+  1996K+ 0B     652K-  681  1    sleeping *0[400+]
398   com.apple.Ap 0.3  00:41.47 2     1    77    704K   0B     436K   398  1    sleeping  0[1]
569   cloudd       0.1  00:19.26 8     3    255   12M-   324K-  3736K  569  1    sleeping *54[1]
659   sharingd     0.1  00:08.68 4     2    247+  9920K+ 0B     5936K  659  1    sleeping *0[1]
73    fseventsd    0.1  00:24.11 14    1    290   2620K  0B     700K   73   1    sleeping *0[1]
894   ClashX       0.1  00:52.46 18    1    279   38M    16K    22M    894  1    sleeping *0[932]
```

输出的第一部分显示的是系统的概况：第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。

平均负载有3个值：最近1分钟的、最近5分钟的和最近15分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见，但如果近15分钟内的平均负载都很高，就说明系统可能有问题。

> **说明** Linux系统管理的要点在于定义究竟到什么程度才算是高负载。这个值取决于系统的硬件配置以及系统上通常运行的程序。对某个系统来说是高负载的值可能对另一系统来说就是正常值。通常，如果系统的负载值超过了2，就说明系统比较繁忙了。

第二行显示了进程概要信息——`top` 命令的输出中将进程叫作 **任务** （task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。

下一行显示了 CPU 的概要信息。`top` 根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将 CPU 利用率分成几类输出。

紧跟其后的两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。

最后一部分显示了当前运行中的进程的详细列表，有些列跟 `ps` 命令的输出类似。

- PID 进程的ID。
- USER 进程属主的名字。
- PR 进程的优先级。
- NI 进程的谦让度值。
- VIRT 进程占用的虚拟内存总量。
- RES 进程占用的物理内存总量。
- SHR 进程和其他进程共享的内存总量。
- S 进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表跟踪状态或停止状态，Z代表僵化状态）。
- %CPU 进程使用的CPU时间比例。
- %MEM 进程使用的内存占可用内存的比例。
- TIME+ 自进程启动到目前为止的CPU时间总量。
- COMMAND 进程所对应的命令行名称，也就是启动的程序名。

默认情况下，`top` 命令在启动时会按照 `%CPU` 值对进程排序。可以在 `top` 运行时使用多种交互命令重新排序。每个交互式命令都是单字符，在 `top` 命令运行时键入可改变 `top` 的行为。

键入 f 允许你选择对输出进行排序的字段，键入 d 允许你修改轮询间隔。键入 q 可以退出`top` 。用户在 `top` 命令的输出上有很大的控制权。用这个工具就能经常找出占用系统大部分资源的罪魁祸首。当然了，一旦找到，下一步就是结束这些进程。

