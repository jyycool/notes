## 一文详解TCP



### 1、TCP报文格式

![TCP报文](/Users/sherlock/Desktop/notes/allPics/network/TCP报文.jpg)

#### 端口号

标记同一台计算机上的不同进程

- ***源端口***：占2个字节，源端口和IP的作用是标记报文的返回地址。 

- ***目的端口***：占2个字节，指明接收方计算机上的应用程序接口。 

  TCP报头中的源端口号和目的端口号同IP报头中的源IP和目的IP唯一确定一条TCP连接。

#### 序号 

占4个字节，是TCP可靠传输的关键部分。是本报文段发送的数据组的第一个字节的序号。 

在TCP传输流中，每一个字节一个序号。（例如：一个报文段的序号为300，此报文数据部分共有100字节，则下一个报文段的序号为400.）所以序号确保了TCP传输的有序性。

#### 确认序号

即ack，占4个字节，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK=1时才有效。比如建立连接时，SYN报文的ACK标志位为0。

#### 头部长度(数据偏移)

由于TCP首部包含一个长度可变的选项和填充部分，所以需要这么一个值来指定这个TCP报文段到底有多长。或者可以这么理解：就是表示TCP报文段中数据部分在整个TCP报文段中的位置。该字段的单位是32位字，即：4个字节。***TCP的滑动窗口大小实际上就是socket的接收缓冲区大小的字节数。***

#### 保留 

为将来定义新的用途保留，一般置为0。

#### 标志位

- URG：指示报文中有紧急数据，应尽快传送（相当于高优先级的数据）。
- PSH：为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
- RST：TCP连接中出现严重差错（如主机崩溃），必须释放连接，在重新建立连接。
- FIN：发送端已完成数据传输，请求释放连接。
- SYN：处于TCP连接建立过程。 （Synchronize Sequence Numbers）
- ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。

#### 窗口

滑动窗口大小，这个字段是接收端用来告知发送端自己还有多少缓冲区可以接受数据。于是发送端可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。（以此控制发送端发送数据的速率，从而达到流量控制。）窗口大小时一个16bit字段，因而窗口大小最大为65535。

#### 校验和

奇偶校验，此校验和是针对整个TCP报文段的，包括TCP报头和TCP报文数据段，以2个字节进行计算所得。由发送端计算和存储，并由接收端进行验证。

#### 紧急指针

只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。

#### 选项和填充部分

TCP报文的字段实现了TCP的功能，标识进程、对字节流拆分组装、差错控制、流量控制、建立和释放连接等。其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*（32/8）-20=40字节。

> 示例:
>
> ```go
> //以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)
> 88 25 93 02 b7 8c 78 4f 43 5b 56 75 08 00 45 00
> 00 40 00 00 40 00 40 06 f6 72 0a 16 46 87 cb d0
> 27 d8 d2 23 01 bb 2e f0 89 c5 00 00 00 00 b0 02
> ff ff b3 39 00 00 02 04 05 b4 01 03 03 05 01 01
> 08 0a 32 a6 80 43 00 00 00 00 04 02 00 00
> 
> //提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)
> d2 23 01 bb 
> 2e f0 89 c5 
> 00 00 00 00 
> b0 02 ff ff 
> b3 39 00 00 
> 02 04 05 b4 01 03 03 05 01 01 08 0a 
> 32 a6 80 43 00 00 00 00 04 02 00 00
> ```
>
> 因为8bit = 1byte, 源端口和目标端口都是16bit = 2byte, 所以从上面可以解析出:
>
> - 源端口号(2byte)：0xd223 = 53795；
>
> - 目的端口号(2byte)：0x01bb = 443；
>
> - 序列号(4byte)：SEQ = 0x2ef089c5；
>
> - 确认序号(4byte): ACK = 0x00000000；
> - TCP报头：`0xb = 11(32 bit)，11 x 4 byte = 44 byte`，即TCP报头长为 44 个字节；
> - 窗口大小(2byte): 0xffff = 65535 byte；
> - 保留位和标志位：0x002 = 0b000000000010；**按位解析标志位为 0b000000010**，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 0，PSH: 0，RST: 0，SYN: 1，FIN: 0，**从解析里面可以看出该报文ACK字段无效，只有SYN字段有效，是第一个请求连接[SYN]同步数据报**；
> - 可选项部分：可以看出该TCP报头最后的24个字节表示可选项，解析如下:
>
> ```go
> 02 04 05 b4            kind = 2, len = 4，MMS Value = 0x05b4 表示MSS = 1460byte
> 01                     kind = 1  No-Operation
> 03 03 05               kind = 3，len = 3，value = 0x05  窗口选项偏移5位，即实际窗口大小为 0xffff x 2^5
> 01                     kind = 1  No-Operation
> 01                     kind = 1  No-Operation
> 08 0a 32 a6 80 43 00 00 00 00   kind = 8，len = 10  时间戳选项，Timestamp Value(TSval): 0x32a68043 = 849772611，Timestamp echo reply(TSecr): 0
> 04 02                  kind = 4，len  =2  SACK Permitted，选择确认选项有效
> 00 00                  kind = 0  补充够32bit，即4byte的倍数
> ```



### 2、三次握手

![三次握手](/Users/sherlock/Desktop/notes/allPics/network/三次握手.png)

最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。

1. TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了**LISTEN（监听）**状态；
2. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的**同部位SYN=1，同时选择一个初始序列号 seq=x **，此时，TCP客户端进程进入了 **SYN-SENT（同步已发送状态）状态**。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 **ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y**，此时，TCP服务器进程进入了**SYN-RCVD（同步收到）**状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4. TCP客户进程收到确认后，还要向服务器给出确认。确认报文的**ACK=1，ack=y+1，自己的序列号seq=x+1**，此时，TCP连接建立，客户端进入**ESTABLISHED（已建立连接）**状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
5. 当服务器收到客户端的确认后也进入**ESTABLISHED**状态，此后双方就可以开始通信了。

三次握手主要目的是：**信息对等和防止超时**。防止超时导致脏连接。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。



### 3、四次挥手

![四次挥手](/Users/sherlock/Desktop/notes/allPics/network/四次挥手.png)

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，**FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）**，此时，客户端进入**FIN-WAIT-1**（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，**ACK=1，ack=u+1，并且带上自己的序列号seq=v**，此时，服务端就进入了**CLOSE-WAIT（关闭等待）**状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于**半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受**。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入**FIN-WAIT-2（终止等待2）**状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，**FIN=1，ack=u+1**，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了**LAST-ACK（最后确认）**状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，**必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1**，此时，客户端就进入了**TIME-WAIT（**时间等待）状态。注意此时TCP连接还没有释放，必须经过**2MSL（最长报文段寿命）**的时间后，当客户端撤销相应的TCB后，才进入**CLOSED**状态。
6. 服务器只要收到了客户端发出的确认，立即进入**CLOSED**状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

**TIME_WAIT**：主动要求关闭的机器表示收到了对方的FIN报文，并发送出了ACK报文，进入TIME_WAIT状态，等2MSL后即可进入到CLOSED状态。如果FIN_WAIT_1状态下，同时收到待FIN标识和ACK标识的报文时，可以直接进入TIME_WAIT状态，而无需经过FIN_WAIT_2状态。

**CLOSE_WAIT**：被动关闭的机器收到对方请求关闭连接的FIN报文，在第一次ACK应答后，马上进入CLOSE_WAIT状态。这种状态其实标识在等待关闭，并且通知应用发送剩余数据，处理现场信息，关闭相关资源。

#### 为什么客户端最后还要等待2MSL？

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。**第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。**站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。如果客户端收到服务端的FIN+ACK报文后，发送一个ACK给服务端之后就“自私”地立马进入CLOSED状态，可能会导致服务端无法确认收到最后的ACK指令，也就无法进入CLOSED状态，这是客户端不负责任的表现。**第二，防止失效请求。**防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

在TIME_WAIT状态无法真正释放句柄资源，在此期间，Socket中使用的本地端口在默认情况下不能再被使用。该限制对于客户端机器来说是无所谓的，但对于高并发服务器来说，会极大地限制有效连接的创建数量，称为性能瓶颈。所以建议将高并发服务器TIME_WAIT超时时间调小。RFC793中规定MSL为2分钟。但是在当前的高速网络中，2分钟的等待时间会造成资源的极大浪费，在高并发服务器上通常会使用更小的值。

在服务器上通过变更/etc/sysctl.conf文件来修改该默认值**net.ipv4.tcp_fin_timout**=30（建议小30s）。修改完之后执行 /sbin/sysctl -p 让参数生效。

通过如下命令查看各连接状态的技术情况：

```shell
[root@node1 ~]# netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
TIME_WAIT 63
ESTABLISHED 13
```

#### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

### 4、滑动窗口

TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。当链路变好了或者变差了这个窗口还会发生变话，并不是第一次协商好了以后就永远不变了。

滑动窗口协议，是TCP使用的一种**流量控制**方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。 只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议又称为滑动窗口协议。

流量控制：端到端，接收端的应用层处理速度决定和网速无关，由接收端返回的rwnd控制

**cwnd**：发送端窗口( congestion window )

**rwnd**：接收端窗口（receiver window）

### 5、拥塞控制

#### 拥塞控制

发送端主动控制cwnd，有慢启动（从cwnd初始为1开始启动，指数启动），拥塞避免（到达ssthresh后，为了避免拥塞开始尝试线性增长），快重传（接收方每收到一个报文段都要回复一个当前最大连续位置的确认，发送方只要一连收到三个重复确认就知道接收方丢包了，快速重传丢包的报文，并TCP马上把拥塞窗口 cwnd 减小到1），快恢复（直接从ssthresh线性增长）

如果网络上的延时突然增加，那么TCP对这个事作出的应对只有重传数据，但是重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。所以TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。

#### 慢启动

只有在TCP连接建立和网络出现超时时才使用。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。另外，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：

- 当 cwnd < ssthresh 时，使用上述的慢开始算法。
- 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
- 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

#### 拥塞避免算法

让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。